<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision`s blog</title>
  
  
  <link href="https://en.decision01.com/atom.xml" rel="self"/>
  
  <link href="https://en.decision01.com/"/>
  <updated>2024-09-20T08:28:39.708Z</updated>
  <id>https://en.decision01.com/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>btcd - Construct transaction with Golang</title>
    <link href="https://en.decision01.com/post/c19159ae.html"/>
    <id>https://en.decision01.com/post/c19159ae.html</id>
    <published>2024-04-08T06:01:32.000Z</published>
    <updated>2024-09-20T08:28:39.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p class="admonition-title">Prologue</p><p>Participating in the Bitcoin ecosystem inevitably involves on-chain operations. Compared to the transaction building mechanism on Ethereum, constructing a Bitcoin transaction requires some programming skills.</p></div><p>Prerequisite knowledge for this post: UTxO, transaction structure, and scripting language，you can learn these on [Learn me a bitcoin](<a href="https://learnmeabitcoin.com/">https://learnmeabitcoin.com/</a>. In addition:</p><ul><li>The visualized testnet transaction pool explorer：<a href="https://mempool.space/testnet">https://mempool.space/testnet</a></li><li>Test bitcoin faucet：<a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li>Private key generator（avoid to use it on mainnet）：<a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a> </li></ul><p>The Bitcoin tool repo: <code>github.com/btcsuite/btcd</code></p><h1 id="Consturct-A-Simple-Transaction"><a href="#Consturct-A-Simple-Transaction" class="headerlink" title="Consturct A Simple Transaction"></a>Consturct A Simple Transaction</h1><h2 id="Generate-the-private-key-and-address"><a href="#Generate-the-private-key-and-address" class="headerlink" title="Generate the private key and address"></a>Generate the private key and address</h2><h3 id="Private-key"><a href="#Private-key" class="headerlink" title="Private key"></a>Private key</h3><p>The private key </p><p>Private key have many different forms. The most common form is Wallet Import Format (WIF), and also form in hex. These forms of private key are interchangeable.</p><div class="admonition note"><p>Actually, most Chrome wallet extensions not support private key import in WIF format.</p></div><p>You can generate private key and derive private key in WIF format with Golang. It also can generate WIF private key from the online BIP-39 website (remember avoid to use it on mainnet).</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The code in the post all defaults to the test network</span></span><br><span class="line">cfg := &amp;chaincfg.TestNet3Params</span><br><span class="line"></span><br><span class="line">privateKey, err := btcec.NewPrivateKey()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wif, err := btcutil.NewWIF(privateKey, cfg, <span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Generated WIF Key: %s&quot;</span>, wif.String())</span><br><span class="line"><span class="comment">// Generated WIF Key: cViUtGHsa6XUxxk2Qht23NKJvEzQq5mJYQVFRsEbB1PmSHMmBs4T</span></span><br></pre></td></tr></table></figure><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>The bitcoin address also have many different format, you can learn it in <a href="https://learnmeabitcoin.com/technical/script/">Script</a> on Learn me a bitcoin.</p><p>Taproot address is the most frequently used type, which is proposed to support the Taproot protocol and other different Pay-To methods.</p><p>The code for generate private key in WIF form is:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taprootAddr, err := btcutil.NewAddressTaproot(</span><br><span class="line">    schnorr.SerializePubKey(</span><br><span class="line">        txscript.ComputeTaprootKeyNoScript(</span><br><span class="line">            wif.PrivKey.PubKey())),</span><br><span class="line">    &amp;chaincfg.TestNet3Params)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Taproot testnet address: %s\n&quot;</span>, taprootAddr.String())</span><br><span class="line"><span class="comment">// Taproot testnet address: tb1p3d3l9m5d0gu9uykqurm4n8xcdmmw9tkhh8srxa32lvth79kz7vysx9jgcr</span></span><br></pre></td></tr></table></figure><p>There are four nested functions here, from innermost to outermost:</p><ul><li>wif.PrivKey.PubKey()：obtian the public key from WIF private key</li><li>txscript.ComputeTaprootKeyNoScript：calculate a public key that used to Schnorr signature from the public key</li><li>schnorr.SerializePubKey：serialize public key to bytecodes</li><li>btcutil.NewAddressTaproot：generate the address from public key in bytecodes format</li></ul><h2 id="Build-transaction"><a href="#Build-transaction" class="headerlink" title="Build transaction"></a>Build transaction</h2><p>The most simplest transaction in Bitcoin is a transaction that just has one input and one output. It transfer the BTC in the input to another address (the receiver).</p><p>Generate a random receiver address：tb1pvwak065fek4y0mup9p4l7t03ey2nu8as7zgcrlgm9mdfl8gs5rzss490qd</p><div class="admonition note"><p>Although it is said to be a 'simple' transaction, the transaction under Taproot is the most complex transaction in Bitcoin. The simpler transaction type is P2PKH.</p></div><p>Before building a transaction, we need to obtain the available UTxO in wallet. Here is the function <code>GetUnspent(address string)</code> be used to obtain the UTxO. We just fill in manually and returns the required UTxO information. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUnspent</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(*wire.OutPoint, *txscript.MultiPrevOutFetcher)</span></span>&#123;</span><br><span class="line"><span class="comment">// the transaction hash and the output index</span></span><br><span class="line">txHash, _ := chainhash.NewHashFromStr(</span><br><span class="line"><span class="string">&quot;7282d54f485561dd21ba22a971b096eb6d0f45ed2fe6bf8c29d87cee162633b4&quot;</span>)</span><br><span class="line">point := wire.NewOutPoint(txHash, <span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// the locking script for the transaction, corresponding to the ScriptPubKey field</span></span><br><span class="line">script, _ := hex.DecodeString(<span class="string">&quot;51208b63f2ee8d7a385e12c0e0f7599cd86ef6e2aed7b9e033762afb177f16c2f309&quot;</span>)</span><br><span class="line">output := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">1000</span>), script)</span><br><span class="line">fetcher := txscript.NewMultiPrevOutFetcher(<span class="literal">nil</span>)</span><br><span class="line">fetcher.AddPrevOut(*point, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> point, fetcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It returns a output point and the previous output fetcher.</p><ul><li>The output point records the transaction hash of the UTxO and the index of the output within the transaction;</li><li>The fetcher records a mapping that indicates what kind of output corresponds to a given output point</li></ul><p>In addition, it is necessary  to decode the address and generate a PayToAddress script under Taproot before build transaction, the implementation code as follows:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeTaprootAddress</span><span class="params">(strAddr <span class="keyword">string</span>, cfg *chaincfg.Params)</span> <span class="params">([]<span class="keyword">byte</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">error)</span></span> &#123;</span><br><span class="line">taprootAddr, err := btcutil.DecodeAddress(strAddr, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byteAddr, err := txscript.PayToAddrScript(taprootAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> byteAddr, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>We can start constructing a simple transaction now. Unlike Ethereal, where a single JSON object can complete the transaction construction. We need to initialize a empty transaction and fill it in manually.</p><p>The input (wire.TxIn) for a new transaction need three parameters: previous output point, signature and witeness script. When constructing the transaction, both of the latter fields are initially set to nil and will be filled in only after the signing is complete.</p><div class="admonition note"><p class="admonition-title">signature and witeness script</p><p>Generally, the witness script and the signature script are independent of each other.</p><p>Alternatively, the witness script acts as a type of signature; it exists independently outside the transaction body and can be pruned by nodes after some time.</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default version = 1</span></span><br><span class="line">tx := wire.NewMsgTx(wire.TxVersion)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the output point in previous transaction as input</span></span><br><span class="line">in := wire.NewTxIn(point, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">tx.AddTxIn(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create new output, pay to the destination address and fill the amount</span></span><br><span class="line">out := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">800</span>), byteAddr)</span><br><span class="line">tx.AddTxOut(out)</span><br></pre></td></tr></table></figure><p>Next, the transaction needs to be signed. The signature is applied to all inputs of the transaction. It is necessary to fill correct unlocking script to the signature or witness field. In Taproot transcation, fill in the witness unlocking script.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obtain the previous transaction</span></span><br><span class="line">prevOutput := fetcher.FetchPrevOutput(in.PreviousOutPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign the transaction by using the private key</span></span><br><span class="line">witness, _ := txscript.TaprootWitnessSignature(tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher), <span class="number">0</span>, prevOutput.Value,</span><br><span class="line">    prevOutput.PkScript, txscript.SigHashDefault, wif.PrivKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill the witness script for input</span></span><br><span class="line">tx.TxIn[<span class="number">0</span>].Witness = witness</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the signed transaction to hex and print</span></span><br><span class="line"><span class="keyword">var</span> signedTx bytes.Buffer</span><br><span class="line">tx.Serialize(&amp;signedTx)</span><br><span class="line">finalRawTx := hex.EncodeToString(signedTx.Bytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Signed Transaction:\n %s&quot;</span>, finalRawTx)</span><br><span class="line"><span class="comment">// Signed Transaction: 01000000000101b4332616ee7cd8298cbfe62fed450f6deb96b071a922ba21dd6155484fd582720000000000ffffffff01200300000000000022512063bb67ea89cdaa47ef81286bff2df1c9153e1fb0f09181fd1b2eda9f9d10a0c5014011a52fdf6ccdda65359ecc9761b199e132d92bb21be059c6c5fb23e86af7152d429dde23314df0db4bcd52428acffab876b8cca1e19d2788a8382c48141b19bd00000000</span></span><br></pre></td></tr></table></figure><p>This section does not cover the code-level details of sending transactions. In simple terms, broadcasting a transaction means publishing it to any blockchain node.</p><p>So, we submit the transaction to <a href="https://mempool.space/testnet/tx/push">Broadcast Transaction</a></p><p>The transaction is <a href="https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f">https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f</a></p><p>The complete code for this section：<a href="https://gist.github.com/Decision2016/18057d0d62b0b5f9716385063fb4c3bc">Simple Bitcoin Transaction - Github Gist</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://mahdidarabi.medium.com/create-raw-bitcoin-transaction-and-sign-it-with-golang-96b5e10c30aa">Create Raw Bitcoin Transaction and Sign It With Golang</a></li><li><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Dev" scheme="https://en.decision01.com/categories/Dev/"/>
    
    
    <category term="blockchain" scheme="https://en.decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="https://en.decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>Generic Programming in Golang</title>
    <link href="https://en.decision01.com/post/26091937.html"/>
    <id>https://en.decision01.com/post/26091937.html</id>
    <published>2023-06-18T08:02:33.000Z</published>
    <updated>2024-09-21T08:50:17.092Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition warning"><p class="admonition-title">warning</p><p>This article was entirely translated by <strong>ChatGPT</strong>. If there are any errors, please feel free to point them out in the comments.</p></div><blockquote><p>The reason for learning generics is that we encountered an issue in the project. In <a href="https://github.com/inkeliz/karmem">karmem</a>, the code for serialization and deserialization is largely similar.</p><p>Therefore, the solution is to write corresponding serialization and deserialization functions for different structs to encapsulate them.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeGeneralParams</span><span class="params">(byteParamsData []<span class="keyword">byte</span>)</span> <span class="params">(*common.GeneralParams, error)</span></span> &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(common.GeneralParams)</span><br><span class="line">generalParams.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, this approach introduces another issue: each time a new struct is added, we need to copy the new functions for serialization and deserialization, which can be quite cumbersome. Therefore, we considered whether we could achieve something similar using generics, as shown below.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeKarmemStruct</span>[<span class="title">T</span> <span class="title">KarmemStruct</span>]<span class="params">(byteParamsData []<span class="keyword">byte</span>)</span> <span class="params">(*T, error)</span></span> &#123;</span><br><span class="line">generalParams := <span class="built_in">new</span>(T)</span><br><span class="line">T.ReadAsRoot(karmem.NewReader(byteParamsData))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> generalParams, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In other words, we aim to consolidate the deserialization of a series of classes generated by Karmem. However, after reviewing various aspects of generics, it seems that we can’t solve this problem.</p></blockquote><h1 id="Parameters-and-Arguments"><a href="#Parameters-and-Arguments" class="headerlink" title="Parameters and Arguments"></a>Parameters and Arguments</h1><p>In a simple implementation of a function that adds two numbers, the <code>a int, b int</code> specified in the function signature are the <strong>parameters</strong>. The values passed in when the function is called are the <strong>arguments</strong>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>By generalizing the concepts of parameters and arguments, we can introduce similar ideas for types, leading to the notions of <strong>type parameters</strong> and <strong>type arguments</strong>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> is the type parameter in this context. It is defined when the function is declared, but the specific type is provided only when the function is called. The concrete type passed in at that time is referred to as the type argument.</p><p>The method for passing type arguments:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add[T=<span class="keyword">int</span>](<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h1 id="Generics-constraints"><a href="#Generics-constraints" class="headerlink" title="Generics constraints"></a>Generics constraints</h1><p><strong>Question</strong></p><p>Considering the example:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a IntSlice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b IntSlice = []<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;</span><br></pre></td></tr></table></figure><p>The assignment to <code>b</code> cannot be achieved because the underlying type of <code>IntSlice</code> is <code>[]int</code>, and a slice of floating-point numbers cannot be assigned.</p><p>If we need slices of different types, we might consider defining a new type for each specific type.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Float32Slice []<span class="keyword">float32</span></span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>Defining a new type for each different member type is <strong>extremely cumbersome</strong>, which is why we turn to generics.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">int</span>|<span class="keyword">float32</span>|<span class="keyword">float64</span>] []T</span><br></pre></td></tr></table></figure><ul><li><code>T</code> is the <strong>type parameter</strong>. When defining a slice, the type it represents is uncertain; it serves as a placeholder;</li><li><code>int|float32|float64</code> is the <strong>type constraint</strong>, which specifies the types of arguments that the type parameter can accept, somewhat similar to defining the types for parameters;</li><li><code>T</code> and <code>int|float32|float64</code> together form the <strong>type parameter list</strong>;</li></ul><h1 id="Generic-function"><a href="#Generic-function" class="headerlink" title="Generic function"></a>Generic function</h1><p>A generic function by using type parameters to replace the existing types:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">float32</span>|<span class="title">float64</span>] <span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unlike the previous implementation, a type constraint is added here to ensure that the function can only use these three types. To use the generic function, you need to pass in type arguments.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add[<span class="keyword">int</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Add[<span class="keyword">float32</span>](<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>It is also possible to pass in parameters directly and let the compiler infer the type arguments (let the compiler deduce the types and then pass in the parameters).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add(1, 2)</span><br><span class="line">Add(1.0, 2.0)</span><br></pre></td></tr></table></figure><p>It is important to note that the generic function cannot be used in the following situations:</p><ul><li><p>Using undefined type parameters in anonymous functions (although defined type parameters can be used);</p></li><li><p>Generic methods are not supported, meaning they cannot be used under a receiver;</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">float32</span>|<span class="title">float64</span>]<span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  However, type parameters can be used through a receiver;</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="keyword">int</span> | <span class="keyword">float32</span> | <span class="keyword">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span> <span class="title">Add</span><span class="params">(a T, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a A[<span class="keyword">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="keyword">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Composition-and-Underlying-Types"><a href="#Composition-and-Underlying-Types" class="headerlink" title="Composition and Underlying Types"></a>Composition and Underlying Types</h1><p>Consider a generic type with a series of type constraints.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">int</span>|<span class="keyword">int8</span>|<span class="keyword">int16</span>|<span class="keyword">int32</span>|...|<span class="keyword">uint32</span>|<span class="keyword">uint64</span>] []T;</span><br></pre></td></tr></table></figure><p>To facilitate the maintenance of such code, it is possible to categorize the types and place the type constraints within interface types. This allows for nesting within type constraints.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>|<span class="keyword">int8</span>|<span class="keyword">int16</span>|<span class="keyword">int32</span>|<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line"> <span class="keyword">uint</span>|<span class="keyword">uint8</span>|<span class="keyword">uint16</span>|<span class="keyword">uint32</span>|<span class="keyword">uint64</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int|Uint] []T</span><br></pre></td></tr></table></figure><p>To simplify the final type definition,the type constraints can be nested within the <code>interface</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>By nesting through <code>interface</code> and combining within type constraints, future maintenance of the code becomes more convenient.</p><p>However, this approach has a drawback: if the type constraint includes a type <code>type1</code>, and another type defines <code>type type2 type1</code>, such a situation will not satisfy the type constraint conditions.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="keyword">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]</span><br></pre></td></tr></table></figure><p>Such code results in an error on the fourth line because, although its underlying type is <code>int</code>, it is not itself of type <code>int</code>, and thus does not meet the type constraint.</p><p>Therefore, the <code>~</code> symbol can be used to represent the underlying type in type constraints, for example, <code>type Slice [T ~int|~float32]</code>. This way, as long as the underlying type meets the constraint, it is acceptable. The limitation of using this symbols are</p><ul><li>The type following the symbol cannot be an interface.</li><li>The type following the symbol must be an underlying type.</li></ul><h1 id="Type-sets"><a href="#Type-sets" class="headerlink" title="Type sets"></a>Type sets</h1><p>Before Go 1.18, the official definition of an interface in Golang was:</p><blockquote><p>An interface type specifies a method set called its interface</p></blockquote><p>For the <code>ReaderWriter</code> interface, it defines an interface that includes a set of <code>Read</code> and <code>Write</code> methods. Any type that defines both of these methods is considered to implement this interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderdWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From another perspective, <code>ReaderWriter</code> can be seen as a set of types. All types that implement both of its methods belong to the type set represented by the interface. This is what we refer to as a type set.</p><p>By using interfaces to simplify type constraints, interfaces now serve the purpose of defining type sets. Originally, they only defined a set of methods, hence referred to as method sets.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">Int|Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure><p>The type interface <code>SliceElement</code> is a type set. All types that satisfy the constraints <code>Int|Uint</code> are included in this type set.</p><p>In <code>type Slice[T SliceElement] []T</code>, the type constraint specifies the set of acceptable types for the type parameter. Only types that belong to this set can replace the type parameter for instantiation.</p><p>The original definition of implementing an interface is: <strong>A type implicitly implements an interface if it implements all the methods of that interface.</strong></p><p>Now, a type T is said to implement an interface I if it meets the following conditions:</p><ul><li>If T is not an interface: <strong>Type</strong> T is a <strong>member</strong> of the type set represented by interface I.</li><li>If T is an interface: The type set represented by interface <strong>T</strong> is a <strong>subset</strong> of the type set represented by interface I.</li></ul><h2 id="Basic-General-Interfaces"><a href="#Basic-General-Interfaces" class="headerlink" title="Basic/General Interfaces"></a>Basic/General Interfaces</h2><p>Basic Interface: In Go versions prior to 1.18, an interface consisting solely of methods is referred to as a basic interface.</p><p>General Interface: If an interface includes not only methods but also types, it is referred to as a general interface.</p><p><strong>General interface types cannot be used to define variables and can only be used to specify generic constraints.</strong></p><p>At this point, we’ve covered the main points. For further details, you can refer to <a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a>, which provides a more comprehensive explanation.</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a></li><li><a href="https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70">https://alankrantas.medium.com/%E7%B0%A1%E5%96%AE%E7%8E%A9-go-1-18-%E6%B3%9B%E5%9E%8B-1d09da07b70</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=</summary>
      
    
    
    
    <category term="Dev" scheme="https://en.decision01.com/categories/Dev/"/>
    
    
    <category term="golang" scheme="https://en.decision01.com/tags/golang/"/>
    
    <category term="generic" scheme="https://en.decision01.com/tags/generic/"/>
    
  </entry>
  
</feed>
