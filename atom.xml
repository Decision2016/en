<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision`s blog</title>
  
  
  <link href="https://en.decision01.com/atom.xml" rel="self"/>
  
  <link href="https://en.decision01.com/"/>
  <updated>2024-09-20T09:21:37.157Z</updated>
  <id>https://en.decision01.com/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BIP-340/1：Schnorr Signature and MAST</title>
    <link href="https://en.decision01.com/post/b45dd1b1.html"/>
    <id>https://en.decision01.com/post/b45dd1b1.html</id>
    <published>2024-04-08T16:15:09.000Z</published>
    <updated>2024-09-20T09:21:37.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Schnorr-签名"><a href="#Schnorr-签名" class="headerlink" title="Schnorr 签名"></a>Schnorr 签名</h1><p>为了简便起见这里都用大整数取模运算下的方式来说明签名、验证过程，签名算法也可以同样地在椭圆曲线上实现</p><h2 id="签名及验证"><a href="#签名及验证" class="headerlink" title="签名及验证"></a>签名及验证</h2><p>Schnorr 签名的单一签名过程较为简单，它涉及到的函数只有哈希函数 $H$ 将消息映射为一个大整数，同时所有的运算在群 $G_p$ 下完成，$p$ 是一个大素数，$G_p$ 的生成元是 $g$</p><p><strong>签名流程</strong></p><p>Schnorr 签名方随机选取一个大整数 $x \in G_p$ 作为私钥，在群 $G_p$ 上运算 $y=g^x$ 作为它的公钥，同时签名方为消息 $m$ 进行签名</p><ul><li>签名方选取随机数 $r \in G_p$，计算 $R = g^r$</li><li>签名方计算哈希值 $e = H(y||m)$</li><li>通过 $r$ 和 $h$，计算 $s=r+ex$</li><li>最后得到签名为 $\sigma = (R,s)$</li></ul><p>这个过程表示为 $\sigma \leftarrow Sign(x,m,r,pp)$，$pp$ 是公开参数，包括群的相关信息以及哈希函数</p><p><strong>签名验证</strong></p><p>在签名验证方，它所具备的公开信息有签名方的公钥 $y=g^x$，签名消息 $m$ 以及签名 $\sigma=(R,s)$，因此验证方可以通过验证下列等式是否成立来验证签名的有效性<br>$$<br>g^s \overset{\text{?}}{=} R \cdot y^e<br>$$<br>在这个等式中，$e = H(y||m)$ 可以通过公开的参数来得到，将它展开，实际上是在验证<br>$$<br>g^{r+ex} \overset{\text{?}}{=} g^r \cdot (g^x)^e<br>$$<br>在正确的私钥和签名过程下，这个等式是必然成立的，如果签名私钥不对或签名运行过程有误，该等式无法成立</p><p>这个过程表示为 ${0,1} \leftarrow Verify(y,m,\theta,pp)$</p><h2 id="签名聚合"><a href="#签名聚合" class="headerlink" title="签名聚合"></a>签名聚合</h2><p>签名聚合依赖于 Schnorr 签名的可加性，考虑两个签名者对同一条消息 $m$ 进行签名，得到</p><p>$$<br>\begin{split}<br>\sigma_1 \leftarrow Sign(x_1,m,r_1,pp) \\<br>\sigma_2 \leftarrow Sign(x_2,m,r_2,pp)<br>\end{split}<br>$$</p><p> 根据签名流程，$\sigma$ 实际上是两个数值 $\sigma = (g^r,s)$，所以有</p><p>$$<br>\begin{split}<br>(R_1,s_1) = (g^{r_1}, r_1+ex_1) \\<br>(R_2,s_2) = (g^{r_2}, r_2+ex_2)<br>\end{split}<br>$$</p><p>对 $R$ 进行相乘，$s$ 进行相加，可以得到聚合签名，它在形式上为 $\sigma_{12} \leftarrow Sign((x_1+x_2),m,(r_1+r_2),pp)$，即下列等式</p><p>$$<br>\sigma_{12} = (g^{r_1+r_2},(r_1+r_2) + e(x_1+x_2))<br>$$</p><div class="admonition warning"><p class="admonition-title">warning</p><p>这样的签名相加方式只是为了展示签名的可加性，以此来达到签名聚合的目的，实际上存在安全问题（密钥抵消攻击<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[比特币中的Schnorr签名](https://zkfold.ing/bitcoin-Schnorr)">[1]</span></a></sup>），不能在实际场景中使用。</p></div><p>基于这样的签名聚合方式，它可以被用于多签交易中，这可以使得多重签名锁定的脚本中不需要包含所有的公钥，进一步保证了交易的隐私性。并且也降低了签名的长度和所需要的参数，在实际的 P2TR 交易中降低了发送者的开销。</p><h2 id="Taproot-地址"><a href="#Taproot-地址" class="headerlink" title="Taproot 地址"></a>Taproot 地址</h2><p>尽管在 <a href="https://decision01.com/post/8a19da7d.html">Bitcoin 支付方式及地址类型</a> 中提到了 taproot 地址的生成、编码方式，但是没有具体涉及到 tweak 公钥的生成是如何实现的，这个公钥基于以下公式<br>$$<br>Q = P + tG<br>$$<br>其中，$Q$ 是 tweak 公钥，$P$ 是椭圆曲线上的公钥，$T=tG$ 代表的是脚本路径映射到椭圆曲线上的点</p><p>在这里，$t = TaggedHash(‘TapTweak’, P||merkleRoot)$，它对公钥和脚本构造形成的 MAST 根哈希值进行进一步的映射，得到一个小于 SECP256K1 曲线的阶的自然数 $t$，然后再将它乘以椭圆曲线的基点 $G$ 映射到椭圆曲线上，得到 $T=tG$</p><p>这个过程可以参考  <a href="https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA">Taproot 及 MuSig2 回顾</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot 及 MuSig2 回顾](https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA)">[4]</span></a></sup> 对地址生成过程的说明</p><p>最后这个 tweak 在进行编码后可以得到 taproot 地址，即主网上常见的 bc1p 开头的地址</p><h1 id="默克尔抽象语法树"><a href="#默克尔抽象语法树" class="headerlink" title="默克尔抽象语法树"></a>默克尔抽象语法树</h1><p>如 <a href="https://decision01.com/post/8a19da7d.html">Bitcoin 支付方式及地址类型</a> 中所描述到的，Taproot 升级中将支付到地址哈希和支付到脚本两种方式整合到了一起</p><p>在 Taproot 中，这被称为私钥路径（Key Path）和脚本路径（Script Path），脚本路径中的脚本通过默克尔抽象语法树（Merklized Abstract Syntax Trees, MAST）来实现脚本哈希值的计算，这种方式使得用户只需要给出单一脚本路径上的代码就可以完成完整的验证。而这里要说明的 MAST 的根哈希值，就是 Taproot 地址生成中所需要的 $t$，它参与到 tweak 公钥的生成</p><p>在这里，考虑下面的脚本（也是大多数讲解 MAST 的文章引用的脚本，它来源于 <a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[5]</span></a></sup>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_IF</span><br><span class="line">&lt;Alice&#x27;s pubkey&gt; OP_CheckSig</span><br><span class="line">OP_ELSE</span><br><span class="line">&quot;3 months&quot; OP_CSV OP_DROP</span><br><span class="line">2 &lt;Bob&#x27;s pubkey&gt; &lt;Charlie&#x27;s pubkey&gt; 2 OP_CHECKMULTISIG</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>MAST 的一个思想是抽象语法树（Abstract Syntax Trees, AST），AST 通过树状结构来表示源代码，通过分支、函数调用来划分代码的各部分，例如上述脚本的 AST 可以构造为如下的方式</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/1*hopXMeyj-k92AvcRSc7J4A.png" alt="img"></p><p>而 MAST 的另外一个思想则是是 Merkle 树，它以此将内容组织为一个二叉树，然后依次对子节点进行哈希运算，最终得到一个根节点哈希，如果要验证一个元素是否在一颗 Merkle 树中，只需要将这个元素和它沿途路径上的哈希值给出即可。根据这样的特性，Merkle 树也是一种密码累加器，成员证明过程在 <a href="https://decision01.com/post/ae4d471f.html">密码累加器</a> 中进行了简单的描述</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202902204.png" alt="image-20230910202902204"></p><p>结合这两种树状结构，如果以 AST 的方式来划分不同的代码片，然后放入到 Merkle 树的叶子节点的内容中，依次哈希就可以得到一个根哈希值（它就是上面公式中的 $t$）。最后，得到的 Merkle 树就是一个 MAST，在运行脚本代码的时候可以只给出一部分叶子节点上的脚本内容以及对应的成员证明即可（即沿途路径上的子节点哈希值）。</p><p>例如，最初脚本中的 MAST 可以构造为如下结构，Alice 可以使用签名脚本，并给出 Hash 2的值；或者由他的好友 Bob 和 Charlie 在三个月后给出第二个脚本，并且给出 Hash 1 的值就可以使用脚本</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202920105.png" alt="image-20230910202920105"></p><p>对脚本这样的组织方式使得用户可以在解锁的时候不需要像 P2SH 一样在解锁的时候需要填入完整的脚本，只需要给出 MAST 的一部分和其他部分的哈希值即可，很好地保护了隐私性</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zkfold.ing/bitcoin-Schnorr">比特币中的Schnorr签名</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr signature</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2023/04/27/taproot-and-musig2-recap-by-elle-mouton/#Taproot-%E8%BE%93%E5%87%BA">Taproot 及 MuSig2 回顾</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Schnorr-签名&quot;&gt;&lt;a href=&quot;#Schnorr-签名&quot;</summary>
      
    
    
    
    <category term="Wiki" scheme="https://en.decision01.com/categories/Wiki/"/>
    
    
    <category term="blockchain" scheme="https://en.decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="https://en.decision01.com/tags/bitcoin/"/>
    
    <category term="cryptography" scheme="https://en.decision01.com/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>btcd - Construct transaction with Golang</title>
    <link href="https://en.decision01.com/post/c19159ae.html"/>
    <id>https://en.decision01.com/post/c19159ae.html</id>
    <published>2024-04-08T06:01:32.000Z</published>
    <updated>2024-09-20T08:28:39.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p class="admonition-title">Prologue</p><p>Participating in the Bitcoin ecosystem inevitably involves on-chain operations. Compared to the transaction building mechanism on Ethereum, constructing a Bitcoin transaction requires some programming skills.</p></div><p>Prerequisite knowledge for this post: UTxO, transaction structure, and scripting language，you can learn these on [Learn me a bitcoin](<a href="https://learnmeabitcoin.com/">https://learnmeabitcoin.com/</a>. In addition:</p><ul><li>The visualized testnet transaction pool explorer：<a href="https://mempool.space/testnet">https://mempool.space/testnet</a></li><li>Test bitcoin faucet：<a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li>Private key generator（avoid to use it on mainnet）：<a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a> </li></ul><p>The Bitcoin tool repo: <code>github.com/btcsuite/btcd</code></p><h1 id="Consturct-A-Simple-Transaction"><a href="#Consturct-A-Simple-Transaction" class="headerlink" title="Consturct A Simple Transaction"></a>Consturct A Simple Transaction</h1><h2 id="Generate-the-private-key-and-address"><a href="#Generate-the-private-key-and-address" class="headerlink" title="Generate the private key and address"></a>Generate the private key and address</h2><h3 id="Private-key"><a href="#Private-key" class="headerlink" title="Private key"></a>Private key</h3><p>The private key </p><p>Private key have many different forms. The most common form is Wallet Import Format (WIF), and also form in hex. These forms of private key are interchangeable.</p><div class="admonition note"><p>Actually, most Chrome wallet extensions not support private key import in WIF format.</p></div><p>You can generate private key and derive private key in WIF format with Golang. It also can generate WIF private key from the online BIP-39 website (remember avoid to use it on mainnet).</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The code in the post all defaults to the test network</span></span><br><span class="line">cfg := &amp;chaincfg.TestNet3Params</span><br><span class="line"></span><br><span class="line">privateKey, err := btcec.NewPrivateKey()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wif, err := btcutil.NewWIF(privateKey, cfg, <span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Generated WIF Key: %s&quot;</span>, wif.String())</span><br><span class="line"><span class="comment">// Generated WIF Key: cViUtGHsa6XUxxk2Qht23NKJvEzQq5mJYQVFRsEbB1PmSHMmBs4T</span></span><br></pre></td></tr></table></figure><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>The bitcoin address also have many different format, you can learn it in <a href="https://learnmeabitcoin.com/technical/script/">Script</a> on Learn me a bitcoin.</p><p>Taproot address is the most frequently used type, which is proposed to support the Taproot protocol and other different Pay-To methods.</p><p>The code for generate private key in WIF form is:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taprootAddr, err := btcutil.NewAddressTaproot(</span><br><span class="line">    schnorr.SerializePubKey(</span><br><span class="line">        txscript.ComputeTaprootKeyNoScript(</span><br><span class="line">            wif.PrivKey.PubKey())),</span><br><span class="line">    &amp;chaincfg.TestNet3Params)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Taproot testnet address: %s\n&quot;</span>, taprootAddr.String())</span><br><span class="line"><span class="comment">// Taproot testnet address: tb1p3d3l9m5d0gu9uykqurm4n8xcdmmw9tkhh8srxa32lvth79kz7vysx9jgcr</span></span><br></pre></td></tr></table></figure><p>There are four nested functions here, from innermost to outermost:</p><ul><li>wif.PrivKey.PubKey()：obtian the public key from WIF private key</li><li>txscript.ComputeTaprootKeyNoScript：calculate a public key that used to Schnorr signature from the public key</li><li>schnorr.SerializePubKey：serialize public key to bytecodes</li><li>btcutil.NewAddressTaproot：generate the address from public key in bytecodes format</li></ul><h2 id="Build-transaction"><a href="#Build-transaction" class="headerlink" title="Build transaction"></a>Build transaction</h2><p>The most simplest transaction in Bitcoin is a transaction that just has one input and one output. It transfer the BTC in the input to another address (the receiver).</p><p>Generate a random receiver address：tb1pvwak065fek4y0mup9p4l7t03ey2nu8as7zgcrlgm9mdfl8gs5rzss490qd</p><div class="admonition note"><p>Although it is said to be a 'simple' transaction, the transaction under Taproot is the most complex transaction in Bitcoin. The simpler transaction type is P2PKH.</p></div><p>Before building a transaction, we need to obtain the available UTxO in wallet. Here is the function <code>GetUnspent(address string)</code> be used to obtain the UTxO. We just fill in manually and returns the required UTxO information. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUnspent</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(*wire.OutPoint, *txscript.MultiPrevOutFetcher)</span></span>&#123;</span><br><span class="line"><span class="comment">// the transaction hash and the output index</span></span><br><span class="line">txHash, _ := chainhash.NewHashFromStr(</span><br><span class="line"><span class="string">&quot;7282d54f485561dd21ba22a971b096eb6d0f45ed2fe6bf8c29d87cee162633b4&quot;</span>)</span><br><span class="line">point := wire.NewOutPoint(txHash, <span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// the locking script for the transaction, corresponding to the ScriptPubKey field</span></span><br><span class="line">script, _ := hex.DecodeString(<span class="string">&quot;51208b63f2ee8d7a385e12c0e0f7599cd86ef6e2aed7b9e033762afb177f16c2f309&quot;</span>)</span><br><span class="line">output := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">1000</span>), script)</span><br><span class="line">fetcher := txscript.NewMultiPrevOutFetcher(<span class="literal">nil</span>)</span><br><span class="line">fetcher.AddPrevOut(*point, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> point, fetcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It returns a output point and the previous output fetcher.</p><ul><li>The output point records the transaction hash of the UTxO and the index of the output within the transaction;</li><li>The fetcher records a mapping that indicates what kind of output corresponds to a given output point</li></ul><p>In addition, it is necessary  to decode the address and generate a PayToAddress script under Taproot before build transaction, the implementation code as follows:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeTaprootAddress</span><span class="params">(strAddr <span class="keyword">string</span>, cfg *chaincfg.Params)</span> <span class="params">([]<span class="keyword">byte</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">error)</span></span> &#123;</span><br><span class="line">taprootAddr, err := btcutil.DecodeAddress(strAddr, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byteAddr, err := txscript.PayToAddrScript(taprootAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> byteAddr, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>We can start constructing a simple transaction now. Unlike Ethereal, where a single JSON object can complete the transaction construction. We need to initialize a empty transaction and fill it in manually.</p><p>The input (wire.TxIn) for a new transaction need three parameters: previous output point, signature and witeness script. When constructing the transaction, both of the latter fields are initially set to nil and will be filled in only after the signing is complete.</p><div class="admonition note"><p class="admonition-title">signature and witeness script</p><p>Generally, the witness script and the signature script are independent of each other.</p><p>Alternatively, the witness script acts as a type of signature; it exists independently outside the transaction body and can be pruned by nodes after some time.</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default version = 1</span></span><br><span class="line">tx := wire.NewMsgTx(wire.TxVersion)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the output point in previous transaction as input</span></span><br><span class="line">in := wire.NewTxIn(point, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">tx.AddTxIn(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create new output, pay to the destination address and fill the amount</span></span><br><span class="line">out := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">800</span>), byteAddr)</span><br><span class="line">tx.AddTxOut(out)</span><br></pre></td></tr></table></figure><p>Next, the transaction needs to be signed. The signature is applied to all inputs of the transaction. It is necessary to fill correct unlocking script to the signature or witness field. In Taproot transcation, fill in the witness unlocking script.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obtain the previous transaction</span></span><br><span class="line">prevOutput := fetcher.FetchPrevOutput(in.PreviousOutPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign the transaction by using the private key</span></span><br><span class="line">witness, _ := txscript.TaprootWitnessSignature(tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher), <span class="number">0</span>, prevOutput.Value,</span><br><span class="line">    prevOutput.PkScript, txscript.SigHashDefault, wif.PrivKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill the witness script for input</span></span><br><span class="line">tx.TxIn[<span class="number">0</span>].Witness = witness</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the signed transaction to hex and print</span></span><br><span class="line"><span class="keyword">var</span> signedTx bytes.Buffer</span><br><span class="line">tx.Serialize(&amp;signedTx)</span><br><span class="line">finalRawTx := hex.EncodeToString(signedTx.Bytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Signed Transaction:\n %s&quot;</span>, finalRawTx)</span><br><span class="line"><span class="comment">// Signed Transaction: 01000000000101b4332616ee7cd8298cbfe62fed450f6deb96b071a922ba21dd6155484fd582720000000000ffffffff01200300000000000022512063bb67ea89cdaa47ef81286bff2df1c9153e1fb0f09181fd1b2eda9f9d10a0c5014011a52fdf6ccdda65359ecc9761b199e132d92bb21be059c6c5fb23e86af7152d429dde23314df0db4bcd52428acffab876b8cca1e19d2788a8382c48141b19bd00000000</span></span><br></pre></td></tr></table></figure><p>This section does not cover the code-level details of sending transactions. In simple terms, broadcasting a transaction means publishing it to any blockchain node.</p><p>So, we submit the transaction to <a href="https://mempool.space/testnet/tx/push">Broadcast Transaction</a></p><p>The transaction is <a href="https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f">https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f</a></p><p>The complete code for this section：<a href="https://gist.github.com/Decision2016/18057d0d62b0b5f9716385063fb4c3bc">Simple Bitcoin Transaction - Github Gist</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://mahdidarabi.medium.com/create-raw-bitcoin-transaction-and-sign-it-with-golang-96b5e10c30aa">Create Raw Bitcoin Transaction and Sign It With Golang</a></li><li><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Dev" scheme="https://en.decision01.com/categories/Dev/"/>
    
    
    <category term="blockchain" scheme="https://en.decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="https://en.decision01.com/tags/bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>BIP, Lighting Network and Trao</title>
    <link href="https://en.decision01.com/post/4f925910.html"/>
    <id>https://en.decision01.com/post/4f925910.html</id>
    <published>2023-05-26T07:19:07.000Z</published>
    <updated>2024-09-20T09:20:36.913Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Bitcoin-Improvement-Proposal"><a href="#Bitcoin-Improvement-Proposal" class="headerlink" title="Bitcoin Improvement Proposal"></a>Bitcoin Improvement Proposal</h1><p>Bitcoin Improvement Proposal (BIP) was proposed by Amir Taaki in <a href="https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki">BIP-0001</a> in 2001. Luke Dash Jr. expanded on this standard in <a href="https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki">BIP-0002</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[什么是BIP？一分钟搞懂BIP标准](https://www.jinse.com/blockchain/465498.html)">[1]</span></a></sup>.</p><blockquote><p>BIP stands for Bitcoin Improvement Proposal. A BIP is a design document providing information to the Bitcoin community, or describing a new feature for Bitcoin or its processes or environment. The BIP should provide a concise technical specification of the feature and a rationale for the feature.</p></blockquote><p>This paper focuses on the Lightning Network and Trao assets, so only some of the relevant standards will be mentioned here.</p><h2 id="Address-types"><a href="#Address-types" class="headerlink" title="Address types"></a>Address types</h2><p>There are four different address types: Legacy, P2SH, SegWit and Taproot<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[科普| 比特币地址有哪些？ - BlockBeats](https://m.theblockbeats.info/news/37101)">[2]</span></a></sup>.The most relevant to Taro assets is the last type - Taproot.</p><h3 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h3><p>Legacy address is the type that have been used since the beginnings of the Bitcoin blockchain. It start with the ascii code - “1”, it is generated by the process shown in the figure.</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312207185.jpg" alt="Legacy(4)"></p><p>According to <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-0032 (Hierarchical Deterministic Wallets)</a> and <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-0044 (Multi-Account Hierarchy for Deterministic Wallets)</a>, a private key can be derived to different public keys. Therefor, it is possible to manage multiple addresses by one private key.</p><p>Because the hash of the public key is used in the address generation process, this address type is also called Pay to Public Key Hash (P2PKH). The sender need to fill PubKey script in transaction to send BTC to receiver address<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[比特币升级提案 Taproot 技术解读](https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/)">[3]</span></a></sup>.</p><h3 id="P2SH"><a href="#P2SH" class="headerlink" title="P2SH"></a>P2SH</h3><p>P2SH is Pay to Script Hash, which is proposed in <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP-0016</a>. The motivation to propose P2SH is:</p><blockquote><p>The purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.</p><p>The benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.</p></blockquote><p>The proposal defines a new transaction type that shifts the conditions and responsibilities for spending UTxOs from the sender to the receiver. Let’s see the BIP-0012.</p><p>P2SH address is proposed in <a href="https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki">BIP-0013</a>. In the previously proposed <a href="https://github.com/bitcoin/bips/blob/master/bip-0012.mediawiki">BIP-0012</a>, an attempt was made to define the reserved OP_NOP1 opcode as a new OP_EVAL opcode to implement P2SH. The function of this opcode is to pop an object from the top of the stack, deserialize it to obtain a script code, and then execute that script code. However, it did not accurately limit the stack depth during the execution of the scripting language, which could cause nodes executing the script to enter an infinite loop. As a result, this soft fork was abandoned before it was enabled.</p><blockquote><p>O’Connor pointed out this vulnerability in <a href="https://github.com/bitcoin/bitcoin/issues/729">issue #729</a>:</p><p>There is one line code in OP_EVAL process:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">EvalScriptInner</span>(stack, subscript, txTo, nIn, nHashType, pbegincodehash, pendcodehash, nOpCount, nSigOpCount, fStrictOpEval, nRecurseDepth++))</span><br></pre></td></tr></table></figure><p>But the return value of <code>nRecurseDepth++</code>is the unincremented variable, which results in the recursion depth not being limited when executing this opcode.</p></blockquote><p>The address generate process in P2SH and P2PKH are the same, the difference is the input used for the final Base58-Check:</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/202305312205969.png" alt="image-20230531220559720"></p><p>P2SH defines a new type of transaction output, which specifies a new script in the scriptPubKey:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_HASH160][ScriptHash][OP_EQUAL]</span><br></pre></td></tr></table></figure><p>这使得发送者只需要在输出中指定使用该输出的发送方所提供的脚本需要满足的条件（脚本代码的hash对应），这样就将进行交易时的费用转移到了接收方而不是发送方，具体的实现原理见 <a href="https://learnmeabitcoin.com/technical/p2sh">How does P2SH work? - learn me a bitcoin</a> 以及脚本语言执行过程 <a href="https://learnmeabitcoin.com/technical/script">Script -A mini programming language</a></p><h3 id="SegWit"><a href="#SegWit" class="headerlink" title="SegWit"></a>SegWit</h3><p>SegWit 是隔离见证（Segregated Witness），隔离见证是一系列的 BIP 标准组成的：</p><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP-0141 (共识层的隔离见证)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP-0143 (定义了新的交易签名算法，以减少验证时的冗余哈希)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP-0144 (在节点层面定义交易的消息和序列化算法)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki">BIP-0145 (为 RPC 接口提供隔离见证的支持)</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki">BIP-0147 (交易有效验证的规则更改))</a></li><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP-0173 (为隔离见证提供的地址格式)</a></li></ul><p>隔离见证的用意是优化比特币交易和区块结构，将交易的签名（scriptSig）从交易中移到另外一个独立的结构中。</p><p>首先考虑比特币交易中的签名，对于 Pay-to-PubKey-Hash 交易，它的输出中的 scriptPubKey 脚本格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OP_DUP][OP_HASH160][PUBLIC_KEY][OP_EQUALVERIFY][OP_CHECKSIG]</span><br></pre></td></tr></table></figure><p>这部分脚本被称为锁定脚本，结合输入中的 scriptSig 形成一段脚本，由矿工在进行交易打包时进行验证，其具体的过程见<a href="https://learnmeabitcoin.com/technical/p2pkh">How does P2PKH work?</a></p><p>而进行隔离见证后，锁定脚本变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION][PUBLIC_KEY]</span><br></pre></td></tr></table></figure><p>在具有隔离见证功能的客户端上，只需要将两个值压栈，第一个数字上版本号，而第二个值是锁定脚本，而在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP - 0143</a> 中，规定了隔离见证的输出应该使用压缩公钥的哈希值来进行创建</p><p>同样地，在原有的另外一种交易类型 P2SH 下，锁定脚本中存放的是一个叫脚本的哈希值，尝试花费这笔 UTxO 的使用者需要提供满足哈希值的签名/口令来使用，在隔离见证后，输出的锁定脚本变为如下所示，这里进一步地减少了输出中的数据量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[VERSION] [SCRIPT_HASH]</span><br></pre></td></tr></table></figure><p>而在隔离见证下，交易的结构中多了一个 <code>witness</code> 字段，解锁 UTxO 的解锁脚本被存放在这一字段下</p><p>另外，为了进一步支持隔离见证交易，对于 SigWit 类型的交易的交易费用会进行“打折”，它原来的交易大小不变，但是在隔离见证下引入的“虚拟大小”比正常的交易更低</p><h3 id="Taproot"><a href="#Taproot" class="headerlink" title="Taproot"></a>Taproot</h3><p>Taproot，翻译为中文是“主根”。</p><blockquote><p><em>A taproot is a large, central, and dominant from which other roots sprout laterally.</em></p></blockquote><p>比特币区块链的 Traproot 升级由三个 BIP 标准组成：<a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP-0340 （Schnorr 签名）</a>、<a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP-0341 （Traproot）</a>和<a href="https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki">BIP-0342 （TapScript）</a></p><p>其中，BIP-0340 中引入了 Schnorr 签名，该签名方案的最大好处是可以聚合签名，它能够使得多位签名整合到一起，从而节省空间<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Schnorr签名对比特币有何意义？](https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin)">[7]</span></a></sup>。</p><h4 id="MAST"><a href="#MAST" class="headerlink" title="MAST"></a>MAST</h4><p>BIP-0341 中引入了默克尔抽象语法树（Merklized Abstract Syntax Tree, MAST）<sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435)">[15]</span></a></sup><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Merklized Abstract Syntax Tree](https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf)">[16]</span></a></sup><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>，其目的是隐藏 UTxO 的支出条件，并且减少信息的大小。这是 Taproot 升级的一部分，Taproot 升级将原有的 P2SH（Pay-to-Script-Hash） 和 P2PKH（Pay-to-Public-Key-Hash）结合在一起，使得一笔数输出可以直接通过私钥使用，也可以提供花费输出的脚本和默克尔证明来使用。</p><p>MAST 结合了抽象语义树和默克尔树，默克尔树作为一种在区块链中常见的数据结构，在这里不再进行赘述。而抽象语法树（AST）是一种把程序分割为独立的小块以描述程序的方法，这样会让程序变得容易分析和优化，具体可查阅<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax tree</a>。MAST 结合了 AST 的将程序划分为多个小块的思想，再把程序每个小块进行哈希，利用默克尔哈希树的思想把这些哈希结果构建为默克尔树。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202902204.png" alt="image-20230910202902204"></p><p>考虑这样一个脚本<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?](https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast)">[17]</span></a></sup>：Alice 希望可以随时花费她的比特币，但是如果她连续三个月没有花费，那么她的兄弟姐妹 Bob 和 Charlie 就可以花费这笔 UTxO，其脚本实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_IF</span><br><span class="line">&lt;Alice&#x27;s pubkey&gt; OP_CheckSig</span><br><span class="line">OP_ELSE</span><br><span class="line">&quot;3 months&quot; OP_CSV OP_DROP</span><br><span class="line">2 &lt;Bob&#x27;s pubkey&gt; &lt;Charlie&#x27;s pubkey&gt; 2 OP_CHECKMULTISIG</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在 P2SH 下，这样的脚本是需要在花费时完全暴露在交易中的，Alice 在花费这笔 UTxO 的同时需要提供该脚本，以及包含在其中的 Bob 和 Charlie 的公钥</p><p>而在有了 MAST 后，对该脚本的两个条件进行划分，得到一个简单的 MAST</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910202920105.png" alt="image-20230910202920105"></p><p>此时，Alice 在花费的时候只需要选择提供她的公钥验证脚本和 Hash2 作为默克尔证明即可，而不需要暴露 Hash 2 下的具体脚本，这部分信息不会上链。而这样也进一步降低了类似交易的开销，这是很自然的，提供完整的脚本总是比提供脚本的哈希值的数据量少。而这样的结构也给智能合约的实现提供了可能，这样的方式正如 EVM 中的字节码一样，在运行前可以根据输入数据的前4个字节来选取将要调用的函数。不同地方在于，这样的脚本调用需要用户提供具体的脚本，以及默克尔证明来证明脚本是合法的。</p><h1 id="多重签名与PSBT"><a href="#多重签名与PSBT" class="headerlink" title="多重签名与PSBT"></a>多重签名与PSBT</h1><h2 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h2><p>多重签名正如其名字一样，一笔交易需要两个或者更多的签名才能生效，多重签名也被称为 <code>n-of-m</code> 交易，指该交易需要 $m$ 个签名者下的至少 $n$ 个签名才能生效</p><p>它的脚本形式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n [PUBLIC_KEY] [PUBLIC_KEY] [PUBLIC_KEY] ... [PUBLIC_KEY] m CHECKMULTISIG</span><br></pre></td></tr></table></figure><p>如果使用 P2PKH 的交易形式来实现多重签名，就需要发送交易的交易方来指定该脚本，并且输入一系列的签名者公钥匙，于是出现了 P2SH 来指定脚本哈希，使得这部分输入输入所产生的开销转移到了使用者</p><h2 id="PSBT"><a href="#PSBT" class="headerlink" title="PSBT"></a>PSBT</h2><p>PSBT 是在 <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP-0174</a> 中所提出的标准，它被用来协助未签名交易（unsigned transactions）的传输</p><p>它可以允许多个签名者并行地对交易进行签名，然后再将交易组装为合成一个完整的 PSBT，目前 Ordinals 相关的交易平台的 Bid 和 Offer 就是利用了 PSBT 来实现</p><p>而 PSBT 也可以被用于实现多重签名</p><h1 id="Ordinals"><a href="#Ordinals" class="headerlink" title="Ordinals"></a>Ordinals</h1><h2 id="序数理论"><a href="#序数理论" class="headerlink" title="序数理论"></a>序数理论</h2><p>序数是一种比特币的编号方案，这是的跟踪和转移单个 sat 成为可能<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup>，它按照每个比特币被挖掘出的顺序以及交易时根据先入先出的规则来进行编号</p><p>序数的表示方式：</p><ul><li>整数符号：<code>2099994106992659</code> 这个序号是根据挖掘聪的顺序分配。</li><li>十进制符号：<code>3891094.16797</code>，第一个数字是挖掘聪的区块高度，第二个数字是区块内聪的偏移量。</li><li>度数符号：<code>3°111094′214″16797‴</code>，具体的度数表示原理见序数理论手册<sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[概述 - 序数理论手册](https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu)">[13]</span></a></sup></li><li>百分数符号：<code>99.99971949060254%</code>。以百分比表示聪在比特币供应中的位置。</li><li>名字：<code>satoshi</code>（聪）。使用字符a到z对序号进行编码。</li></ul><h2 id="铭刻"><a href="#铭刻" class="headerlink" title="铭刻"></a>铭刻</h2><p>铭文的铭刻利用了隔离见证后的特性<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[解读比特币Ordinals协议与BRC20标准的原理创新与局限](https://www.odaily.news/post/5187233)">[12]</span></a></sup>，即将见证脚本放入到交易本身之外的一个 <code>witness</code> 字段中，使用隔离见证的交易只需要 20% 的交易费用</p><p>铭文的相关内容被放入到脚本中，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OP_FALSE</span><br><span class="line">OP_IF</span><br><span class="line">OP_PUSH &quot;ord&quot;</span><br><span class="line">OP_1</span><br><span class="line">OP_PUSH &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">OP_0</span><br><span class="line">OP_PUSH &quot;Hello, world!&quot;</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure><p>在这里，<code>OP_1</code> 指示下一次压入包含内容类型，<code>OP_0</code> 指示后续数据压入包含内容本身</p><p>开头的 <code>OP_FALSE</code> 指令入栈后脚步立刻停止，但是由于隔离见证的特性，这部分数据依然在链上存在，所以 Ordinals Inscription 的本质是在比特币上借助这样一个用于不能被执行的脚步来实现一个记账的功能</p><p>所以，<strong>铭文的索引只能高度依赖链下的中心化索引</strong>，这样铭刻的一个铭文在链下会被记录到对应输出的第一个聪上，在 ordinals.com 中可以看到每个聪的相关信息，以及它是否存在铭刻的数据，目前索引这些铭文（Ordinals Inscription）的程序在 <a href="https://github.com/ordinals/ord">https://github.com/ordinals/ord</a> 维护</p><p>例如 <a href="https://ordinals.com/inscription/6fb976ab49dcec017f1e201e84395983204ae1a7c2abf7ced0a85d692e442799i0">inscription#0</a>，它被铭刻在了序数为 1252201400444387 的聪上</p><h1 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h1><p>闪电网络是建立在 Bitcoin 上的 Layer 2 解决方案，其目的是在 Bitcoin 的支付场景下帮助用户节省成本、提高效率。而闪电网络所依赖的思想也很简单，即构建资金池，这样的资金池也被称为交易双方的微支付通道。更具体一点，涉及到两个核心概念：</p><ul><li>Revocable Sequence Maturity Contract（RSMC）：序列到期可撤销合影</li><li>Hashed Timelock Contract（HTLC）：哈希时间锁定合约</li></ul><p>RSMC 假定了交易双方之间存在一个微支付通道，双方先存放一部分资金到这个通道中，初始情况下双方的分配方案就是预先存放的金额。在每一次发生交易时，双方都需要对交易后产生的分配结果进行确认，同时把原有的分配方案作废。这个过程涉及到的概念较多，而且比较巧妙，具体可参阅 <a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a><sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A Dive into Lightning Network (Part One)]([A Dive into Lightning Network (Part One)](https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2))">[18]</span></a></sup>，而它的作用是在闪电网络中的作用是构建双方之间的支付通道。</p><p>HTLC 是一种带事件的哈希锁定，它要求某一方在一定时间内提交某个哈希值 $h=H(m)$ 的原像 $m$ 以取得使用某一笔 UTxO 使用权。它在闪电网络中被用于构建支付路由，具体的实现过程见 <a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Lightning network in depth, part 2: HTLC and payment routing](https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8)">[19]</span></a></sup>。</p><p>闪电网络整合了这两种机制，使得交易可以在闪电网络中的任意两个节点间能够在链下完成。</p><h1 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h1><p>主根资产（Taproot Assets，后续简称为 Taro）<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What Is Taro in Bitcoin?](https://river.com/learn/what-is-taro-in-bitcoin/)">[20]</span></a></sup><sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets](https://docs.lightning.engineering/the-lightning-network/taproot-assets)">[21]</span></a></sup><sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning](https://www.youtube.com/watch?v=-yiTtO_p3Cw)">[22]</span></a></sup>是一种还在提议阶段的协议，它可以实现在 Bitcoin 上发行资产，这样的资产可以通过链上的交易通过比特币网络转移（对 NFT 的交易、转移已经被 Ordinals 实现）。特别地，同质化的 Taro 资产可以在存入闪电通道后在闪电网络上以更低的手续费、更为隐私地转移，类似的还有尝试在闪电网络上运行智能合约的 RGB 协议<sup id="fnref:23"><a href="#fn:23" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[A BRIEF INTRODUCTION TO RGB PROTOCOLS](https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols)">[23]</span></a></sup>。</p><p>Taro 可以在 Bitcoin 主网或二层的闪电网络上流通。先考虑在 Bitcoin 网络的情况，Taro 是附加在交易上的<strong>哈希化元数据形式</strong>，使用哈希化的目的在于降低交易的占用空间以节省手续费。而这样的<strong>哈希化元数据形式</strong>则是 Taro 的核心，这样的一条哈希值甚至可以代表实际上的几百万次交易，它的原理会在后续进行介绍。</p><p>其次是 Taro 在闪电网络上的情况，使用闪电网络可以让同质化的 Taro 资产实现更快的交易速度，这类似于使用闪电网络可以更快、成本更低地转移比特币。在 Taro 的提议中，闪电网络自身不需要改变，为了实现一笔某种 Taro 资产的交易，只需要整条支付路径的第一条通道和最后一条通道可以识别 Taro 资产即可，而中途的路由通道则是正常的闪电网络转账方法，它们转账等价的比特币，这也导致 Taro 资产通常会在网络的边缘和其他资产交换。下图是 RIVER FINANCIAL 所展示的在闪电网络中实现 Taro 资产转移的过程。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/taro-lightning-network.png" alt="Taro assets exchanged on the Lightning Network"></p><h3 id="资产树"><a href="#资产树" class="headerlink" title="资产树"></a>资产树</h3><p>资产树是 Taro 中的一种两级默克尔树结构，它被用来代表 Taro 资产。第一级是由 Taro 信息作为叶子节点而构成的默克尔树，而第二级则是通过 MS-SMT 构成的表示每个账户所具有的该资产的树，MS-SMT 的思想较为简单，它在默克尔哈希树基于哈希来构成树形结构的同时，每个节点还存放了左右两个子节点的和来实现（进行哈希运算本身也算一种求和），这样的资产树和 MS-SMT 树被用来构建 Taro 的 UTxO。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203608411.png" alt="image-20230910203608411"></p><p>资产叶（Aseet Leaft）是资产树中的最底层结构，它表现为资产树示意图中的淡蓝色节点，它以 assetScriptKey （assetScriptKey 可以类比 P2SH 交易中对交易脚本的哈希值）作为键。每个资产叶表示 Taro 资产的一个 UTxO，资产叶中包含的可选项可参见 <a href="https://medium.com/nayuta-en/understanding-taproot-assets-protocol-e2dfe3fc1e07">Understanding Taproot Assets Protocol</a>。</p><h3 id="Taro-资产发行"><a href="#Taro-资产发行" class="headerlink" title="Taro 资产发行"></a>Taro 资产发行</h3><p>Taro 资产的发行需要一个标识符，正如 ERC-20 代币的智能合约会拥有一个地址一样，Taro 协议定义了标识符的生成方式：<br>$$<br>ID=SHA256(genesisPoint||assetTag||assetMeta)<br>$$<br>它将铸造资产所使用的交易输出信息、资产标签（例如资产名称的哈希值）以及资产的元数据（图片、链接或文档）进行哈希，从而得到一个标识符。</p><p>Taro 资产的转移脚本可以有类似比特币交易的输入输出，而创建资产的交易不需要包含任何的 Taro 资产的输入，由此可见，Taro 资产沿用了比特币的 UTxO 模型，资产的发行就是发布一笔 Taro 资产的交易，它没有输入，只有输出。</p><p>Taro 的输入和输出是基于资产树来实现的，正如前文所述，资产树的第一级代表了该笔 UTxO* （后面会继续沿用这种写法，*表明这样的结构是在 Taro 资产中而非 Bitcoin中）中存放的 Taro 资产有哪些，而 Taro 资产 ID 所对应的 MS-SMT 中所存放的是该笔 UTxO* 输出的 Trao 资产的信息。</p><p>构建一笔 Taro 资产的发行交易如下图所示，以一笔 Bitcoin 的 UTxO 作为输入，输出一笔正常的 Bitcoin UTxO 以及附加的 Taro 资产 A 的 UTxO*。<strong>这样的 UTxO*在 Bitcoin 上表现为一个默克尔根的形式</strong>，而它在链下表现为资产树的形式，资产树中记录了 Taro 资产 A 的 assetId 以及资产 A 对应的 MS-SMT 中的记录。</p><p><img src="https://photos-1301077237.cos.na-siliconvalley.myqcloud.com/image-20230910203812171.png" alt="image-20230910203812171"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.jinse.com/blockchain/465498.html">什么是BIP？一分钟搞懂BIP标准</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://m.theblockbeats.info/news/37101">科普| 比特币地址有哪些？ - BlockBeats</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/29/bitcoin-taproot-a-technical-explanation/">比特币升级提案 Taproot 技术解读</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://juejin.cn/post/6844903573742944263">译-BIP16:P2SH交易脚本</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2022/04/20/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war/">P2SH 之争：第一次比特币战争不为人知的故事</a><a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/technical/the-battle-for-p2sh-the-untold-story-of-the-first-bitcoin-war">THE BATTLE FOR P2SH: THE UNTOLD STORY OF THE FIRST BITCOIN WAR</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://academy.binance.com/zh/articles/what-do-schnorr-signatures-mean-for-bitcoin">Schnorr签名对比特币有何意义？</a><a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.bitcoin.it/wiki/Segregated_Witness">Segregated Witness</a><a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2021/09/07/what-is-a-bitcoin-merklized-abstract-syntax-tree-mast/">什么是比特币默克尔化抽象语法树？</a><a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.btcstudy.org/2020/08/27/segregated-witness-for-dummies/">详尽解释隔离见证</a><a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.blocktempo.com/segwit-for-dummies-concept-and-case-study/">詳解》比特幣隔離見證 Segwit －工作原理與案例分析</a><a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.odaily.news/post/5187233">解读比特币Ordinals协议与BRC20标准的原理创新与局限</a><a href="#fnref:12" rev="footnote"> ↩</a></span></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.ordinalscn.org/xu-shu-li-lun-shou-ce/yi-gai-shu">概述 - 序数理论手册</a><a href="#fnref:13" rev="footnote"> ↩</a></span></li><li id="fn:14"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://newbtcworld.medium.com/understanding-of-tapscript-transaction-structure-5979a7645205">Understanding of Tapscript Transaction Structure Tapscript</a><a href="#fnref:14" rev="footnote"> ↩</a></span></li><li id="fn:15"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://xiaohuiliu.medium.com/merkelized-abstract-syntax-tree-6a49b2008435">Merklized Abstract Syntax Tree</a><a href="#fnref:15" rev="footnote"> ↩</a></span></li><li id="fn:16"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.mit.edu/~jlrubin/public/pdfs/858report.pdf">Merklized Abstract Syntax Tree</a><a href="#fnref:16" rev="footnote"> ↩</a></span></li><li id="fn:17"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.bitcoininsider.org/article/13814/what-bitcoin-merklized-abstract-syntax-tree-mast">What is a Bitcoin Merklized Abstract Syntax Tree (MAST)?</a><a href="#fnref:17" rev="footnote"> ↩</a></span></li><li id="fn:18"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">[A Dive into Lightning Network (Part One)](<a href="https://medium.com/huobi-research/a-dive-into-lightning-network-part-one-90036e3019b2">A Dive into Lightning Network (Part One)</a>)<a href="#fnref:18" rev="footnote"> ↩</a></span></li><li id="fn:19"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://medium.com/softblocks/lightning-network-in-depth-part-2-htlc-and-payment-routing-db46aea445a8">Lightning network in depth, part 2: HTLC and payment routing</a><a href="#fnref:19" rev="footnote"> ↩</a></span></li><li id="fn:20"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://river.com/learn/what-is-taro-in-bitcoin/">What Is Taro in Bitcoin?</a><a href="#fnref:20" rev="footnote"> ↩</a></span></li><li id="fn:21"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://docs.lightning.engineering/the-lightning-network/taproot-assets">Taproot Assets</a><a href="#fnref:21" rev="footnote"> ↩</a></span></li><li id="fn:22"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.youtube.com/watch?v=-yiTtO_p3Cw">Taproot Assets: A New Protocol for Multi-Asset Bitcoin and Lightning</a><a href="#fnref:22" rev="footnote"> ↩</a></span></li><li id="fn:23"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://bitcoinmagazine.com/guides/a-brief-introduction-to-rgb-protocols">A BRIEF INTRODUCTION TO RGB PROTOCOLS</a><a href="#fnref:23" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;Bitcoin-Improvement-Proposal&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Wiki" scheme="https://en.decision01.com/categories/Wiki/"/>
    
    
    <category term="blockchain" scheme="https://en.decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="https://en.decision01.com/tags/bitcoin/"/>
    
  </entry>
  
</feed>
