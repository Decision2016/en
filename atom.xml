<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Decision`s blog</title>
  
  
  <link href="https://en.decision01.com/atom.xml" rel="self"/>
  
  <link href="https://en.decision01.com/"/>
  <updated>2024-09-20T08:28:39.708Z</updated>
  <id>https://en.decision01.com/</id>
  
  <author>
    <name>Decision</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>btcd - Construct transaction with Golang</title>
    <link href="https://en.decision01.com/post/c19159ae.html"/>
    <id>https://en.decision01.com/post/c19159ae.html</id>
    <published>2024-04-08T06:01:32.000Z</published>
    <updated>2024-09-20T08:28:39.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="admonition note"><p class="admonition-title">Prologue</p><p>Participating in the Bitcoin ecosystem inevitably involves on-chain operations. Compared to the transaction building mechanism on Ethereum, constructing a Bitcoin transaction requires some programming skills.</p></div><p>Prerequisite knowledge for this post: UTxO, transaction structure, and scripting language，you can learn these on [Learn me a bitcoin](<a href="https://learnmeabitcoin.com/">https://learnmeabitcoin.com/</a>. In addition:</p><ul><li>The visualized testnet transaction pool explorer：<a href="https://mempool.space/testnet">https://mempool.space/testnet</a></li><li>Test bitcoin faucet：<a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li>Private key generator（avoid to use it on mainnet）：<a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a> </li></ul><p>The Bitcoin tool repo: <code>github.com/btcsuite/btcd</code></p><h1 id="Consturct-A-Simple-Transaction"><a href="#Consturct-A-Simple-Transaction" class="headerlink" title="Consturct A Simple Transaction"></a>Consturct A Simple Transaction</h1><h2 id="Generate-the-private-key-and-address"><a href="#Generate-the-private-key-and-address" class="headerlink" title="Generate the private key and address"></a>Generate the private key and address</h2><h3 id="Private-key"><a href="#Private-key" class="headerlink" title="Private key"></a>Private key</h3><p>The private key </p><p>Private key have many different forms. The most common form is Wallet Import Format (WIF), and also form in hex. These forms of private key are interchangeable.</p><div class="admonition note"><p>Actually, most Chrome wallet extensions not support private key import in WIF format.</p></div><p>You can generate private key and derive private key in WIF format with Golang. It also can generate WIF private key from the online BIP-39 website (remember avoid to use it on mainnet).</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The code in the post all defaults to the test network</span></span><br><span class="line">cfg := &amp;chaincfg.TestNet3Params</span><br><span class="line"></span><br><span class="line">privateKey, err := btcec.NewPrivateKey()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wif, err := btcutil.NewWIF(privateKey, cfg, <span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Generated WIF Key: %s&quot;</span>, wif.String())</span><br><span class="line"><span class="comment">// Generated WIF Key: cViUtGHsa6XUxxk2Qht23NKJvEzQq5mJYQVFRsEbB1PmSHMmBs4T</span></span><br></pre></td></tr></table></figure><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>The bitcoin address also have many different format, you can learn it in <a href="https://learnmeabitcoin.com/technical/script/">Script</a> on Learn me a bitcoin.</p><p>Taproot address is the most frequently used type, which is proposed to support the Taproot protocol and other different Pay-To methods.</p><p>The code for generate private key in WIF form is:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">taprootAddr, err := btcutil.NewAddressTaproot(</span><br><span class="line">    schnorr.SerializePubKey(</span><br><span class="line">        txscript.ComputeTaprootKeyNoScript(</span><br><span class="line">            wif.PrivKey.PubKey())),</span><br><span class="line">    &amp;chaincfg.TestNet3Params)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Taproot testnet address: %s\n&quot;</span>, taprootAddr.String())</span><br><span class="line"><span class="comment">// Taproot testnet address: tb1p3d3l9m5d0gu9uykqurm4n8xcdmmw9tkhh8srxa32lvth79kz7vysx9jgcr</span></span><br></pre></td></tr></table></figure><p>There are four nested functions here, from innermost to outermost:</p><ul><li>wif.PrivKey.PubKey()：obtian the public key from WIF private key</li><li>txscript.ComputeTaprootKeyNoScript：calculate a public key that used to Schnorr signature from the public key</li><li>schnorr.SerializePubKey：serialize public key to bytecodes</li><li>btcutil.NewAddressTaproot：generate the address from public key in bytecodes format</li></ul><h2 id="Build-transaction"><a href="#Build-transaction" class="headerlink" title="Build transaction"></a>Build transaction</h2><p>The most simplest transaction in Bitcoin is a transaction that just has one input and one output. It transfer the BTC in the input to another address (the receiver).</p><p>Generate a random receiver address：tb1pvwak065fek4y0mup9p4l7t03ey2nu8as7zgcrlgm9mdfl8gs5rzss490qd</p><div class="admonition note"><p>Although it is said to be a 'simple' transaction, the transaction under Taproot is the most complex transaction in Bitcoin. The simpler transaction type is P2PKH.</p></div><p>Before building a transaction, we need to obtain the available UTxO in wallet. Here is the function <code>GetUnspent(address string)</code> be used to obtain the UTxO. We just fill in manually and returns the required UTxO information. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUnspent</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(*wire.OutPoint, *txscript.MultiPrevOutFetcher)</span></span>&#123;</span><br><span class="line"><span class="comment">// the transaction hash and the output index</span></span><br><span class="line">txHash, _ := chainhash.NewHashFromStr(</span><br><span class="line"><span class="string">&quot;7282d54f485561dd21ba22a971b096eb6d0f45ed2fe6bf8c29d87cee162633b4&quot;</span>)</span><br><span class="line">point := wire.NewOutPoint(txHash, <span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// the locking script for the transaction, corresponding to the ScriptPubKey field</span></span><br><span class="line">script, _ := hex.DecodeString(<span class="string">&quot;51208b63f2ee8d7a385e12c0e0f7599cd86ef6e2aed7b9e033762afb177f16c2f309&quot;</span>)</span><br><span class="line">output := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">1000</span>), script)</span><br><span class="line">fetcher := txscript.NewMultiPrevOutFetcher(<span class="literal">nil</span>)</span><br><span class="line">fetcher.AddPrevOut(*point, output)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> point, fetcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It returns a output point and the previous output fetcher.</p><ul><li>The output point records the transaction hash of the UTxO and the index of the output within the transaction;</li><li>The fetcher records a mapping that indicates what kind of output corresponds to a given output point</li></ul><p>In addition, it is necessary  to decode the address and generate a PayToAddress script under Taproot before build transaction, the implementation code as follows:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeTaprootAddress</span><span class="params">(strAddr <span class="keyword">string</span>, cfg *chaincfg.Params)</span> <span class="params">([]<span class="keyword">byte</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">error)</span></span> &#123;</span><br><span class="line">taprootAddr, err := btcutil.DecodeAddress(strAddr, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">byteAddr, err := txscript.PayToAddrScript(taprootAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> byteAddr, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>We can start constructing a simple transaction now. Unlike Ethereal, where a single JSON object can complete the transaction construction. We need to initialize a empty transaction and fill it in manually.</p><p>The input (wire.TxIn) for a new transaction need three parameters: previous output point, signature and witeness script. When constructing the transaction, both of the latter fields are initially set to nil and will be filled in only after the signing is complete.</p><div class="admonition note"><p class="admonition-title">signature and witeness script</p><p>Generally, the witness script and the signature script are independent of each other.</p><p>Alternatively, the witness script acts as a type of signature; it exists independently outside the transaction body and can be pruned by nodes after some time.</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default version = 1</span></span><br><span class="line">tx := wire.NewMsgTx(wire.TxVersion)</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the output point in previous transaction as input</span></span><br><span class="line">in := wire.NewTxIn(point, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">tx.AddTxIn(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create new output, pay to the destination address and fill the amount</span></span><br><span class="line">out := wire.NewTxOut(<span class="keyword">int64</span>(<span class="number">800</span>), byteAddr)</span><br><span class="line">tx.AddTxOut(out)</span><br></pre></td></tr></table></figure><p>Next, the transaction needs to be signed. The signature is applied to all inputs of the transaction. It is necessary to fill correct unlocking script to the signature or witness field. In Taproot transcation, fill in the witness unlocking script.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obtain the previous transaction</span></span><br><span class="line">prevOutput := fetcher.FetchPrevOutput(in.PreviousOutPoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign the transaction by using the private key</span></span><br><span class="line">witness, _ := txscript.TaprootWitnessSignature(tx,</span><br><span class="line">    txscript.NewTxSigHashes(tx, fetcher), <span class="number">0</span>, prevOutput.Value,</span><br><span class="line">    prevOutput.PkScript, txscript.SigHashDefault, wif.PrivKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill the witness script for input</span></span><br><span class="line">tx.TxIn[<span class="number">0</span>].Witness = witness</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert the signed transaction to hex and print</span></span><br><span class="line"><span class="keyword">var</span> signedTx bytes.Buffer</span><br><span class="line">tx.Serialize(&amp;signedTx)</span><br><span class="line">finalRawTx := hex.EncodeToString(signedTx.Bytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Signed Transaction:\n %s&quot;</span>, finalRawTx)</span><br><span class="line"><span class="comment">// Signed Transaction: 01000000000101b4332616ee7cd8298cbfe62fed450f6deb96b071a922ba21dd6155484fd582720000000000ffffffff01200300000000000022512063bb67ea89cdaa47ef81286bff2df1c9153e1fb0f09181fd1b2eda9f9d10a0c5014011a52fdf6ccdda65359ecc9761b199e132d92bb21be059c6c5fb23e86af7152d429dde23314df0db4bcd52428acffab876b8cca1e19d2788a8382c48141b19bd00000000</span></span><br></pre></td></tr></table></figure><p>This section does not cover the code-level details of sending transactions. In simple terms, broadcasting a transaction means publishing it to any blockchain node.</p><p>So, we submit the transaction to <a href="https://mempool.space/testnet/tx/push">Broadcast Transaction</a></p><p>The transaction is <a href="https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f">https://mempool.space/testnet/tx/f11f3edccb9988729ba4896e1da82b799a7b4e70cca82aa212058076dd49d76f</a></p><p>The complete code for this section：<a href="https://gist.github.com/Decision2016/18057d0d62b0b5f9716385063fb4c3bc">Simple Bitcoin Transaction - Github Gist</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://mahdidarabi.medium.com/create-raw-bitcoin-transaction-and-sign-it-with-golang-96b5e10c30aa">Create Raw Bitcoin Transaction and Sign It With Golang</a></li><li><a href="https://learnmeabitcoin.com/">Learn me a bitcoin</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;ad</summary>
      
    
    
    
    <category term="Dev" scheme="https://en.decision01.com/categories/Dev/"/>
    
    
    <category term="blockchain" scheme="https://en.decision01.com/tags/blockchain/"/>
    
    <category term="bitcoin" scheme="https://en.decision01.com/tags/bitcoin/"/>
    
  </entry>
  
</feed>
